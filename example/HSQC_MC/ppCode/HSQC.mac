#########################################################
# 
# HSQC
#
# A pulse sequence suitable for performing an HSQC experiment
#
# H 90-d-180-d-90-evo-180-evo-90-d-180-acqu-
# C -----180-d-90-evo-----evo-90-d-180-dec--
# G --G-----G--------G---G------G-----G----G
#
# Copyright (c) Magritek Ltd 2024
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(HSQC, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"HSQC")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("HSQC")
   else
      gExpt->addExperiment(ppGroup,"HSQC",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["wEvo"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["b1Freq        = b1Freq1H",
          "d90C          = pulseLengthC180/2",
          "d270C         = 3*pulseLengthC180/2",
          "d360C         = 2*pulseLengthC180",
          "d180C         = pulseLengthC180",
          "nPnts         = nrPnts",
          "nxShim        = xshim",
          "nyShim        = yshim",
          "nzShim        = zshim",
          "nxSpoil1      = xshim-(spoilAmp*xshim/(abs(xshim)+0.1))",
          "nySpoil1      = yshim-(spoilAmp*yshim/(abs(yshim)+0.1))",
          "nzSpoil1      = zshim-(spoilAmp*zshim/(abs(zshim)+0.1))",
          "nxSpoil2      = xshim-(0.75*spoilAmp*xshim/(abs(xshim)+0.1))",
          "nySpoil2      = yshim-(0.0*spoilAmp*yshim/(abs(yshim)+0.1))",
          "nzSpoil2      = zshim-(0.0*spoilAmp*zshim/(abs(zshim)+0.1))",
          "a90HC         = 90AmplitudeHC",
          "a180HC        = 180AmplitudeHC",
          "a90C          = 90Amplitude13C",
          "a180C         = 0",
          "aDec          = aCDec",
          "dPulse        = pulseLength13C",
          "dSpoil        = spoilDur",
          "dSpoil2       = 2*spoilDur",
          "dStab         = gradStab",
          "dCoup         = 1e6/(4*jch)-pulseLength13C/2-dSpoil-dStab",
          "bandwidth2    = single(bandwidthf1PPM*b1Freq13C/1000)",
          "wEvo          = 1e3/(2*bandwidth2)*nrSteps",
          "offFreq13C    = (centerFreq13CPPM-wvPPMOffset13C)*b1Freq13C",
          "offFreq1H     = (centerFreq1HPPM-wvPPMOffset1H)*b1Freq1H",
          "O1            = offFreq1H",
          "f1H           = double(b1Freq1H)+double(offFreq1H/1e6d)",
          "f13C          = double(b1Freq13C)+double(offFreq13C/1e6d)",
          "totPnts       = nrPnts",
          "totTime       = acqTime",
          "waltzDuration = WALTZ16:duration(pulseLengthC180/2,pgo)",
          "nLoops        = trunc(1000*acqTime/waltzDuration)+1"]
   var = ["wEvo"]
   pp_list = ["nPnts","aDec","f13C","f1H","a90HC","p1","dPulse","nxSpoil1","nySpoil1","nzSpoil1","dSpoil","nxShim","nyShim","nzShim","dStab","dCoup","p2","a90C","p5","a180HC","p3","a180C","p7","p8","wEvo","dSpoil2","p4","p9","nySpoil2","nzSpoil2","p6","p10","d270C","nLoops","lWaltzDec","p12","p11","d360C","d180C","d90C"]
   pp_name = "HSQC.p"
   phase_list = [0,0,0,0;0,0,0,0;1,1,1,1;0,0,0,0;1,1,1,1;0,0,0,0;0,0,0,0;0,2,0,2;0,0,2,2;0,0,0,0;0,0,0,0;2,2,2,2;0,2,2,0]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 26/2/2021 CDE
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Optimise 13C performance on Multi-X spectrometer
   SpinsolveParameterUpdater:setXChannel("13C")

# Make all gui parameters available
   assignlist(guipar)

# Storage for output data
   sumData = cmatrix(totPnts)
   sumData2D = cmatrix(totPnts, nrSteps)
   imageData2D = cmatrix(totPnts*zf, nrSteps*zf)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # ms
   fAxis = [-totPnts*zf/2:totPnts*zf/2-1]/(totTime*zf)*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (prt,prf,pd1,pd2) = ucsPlot:getPlotReferences()

# Work out frequency axes scales, labels and ranges
   (fAxisDisp,fAxisLabel,axisLabely,
    axisLabelx,axisY,axisX,yRange,xRange) = ucsPlot:generate2DFrequencyAxes(prf, pd2, fAxis, b1Freq13C, b1Freq1H, 
                                                                            wvPPMOffset13C, wvPPMOffset1H, 
                                                                            offFreq13C, offFreq1H, 
                                                                            dispRangeMinPPMf1,dispRangeMaxPPMf1,
                                                                            dispRangeMinPPM,dispRangeMaxPPM,
                                                                            guipar)
   bw2Hz = bandwidth2*1000

# Loop over the evolution time
   for(evoStep = -dummyCycles to nrSteps-1)   # evoStep <= 0 is dummy scan

    # Set the mixing time
      if (evoStep >= 0)
         evolutionTime = 1e3/bandwidth2*(evoStep+1)
      else
         evolutionTime = 1e3/bandwidth2
      endif
      wEvo = (evolutionTime-dPulse-pgo)/2
      ppList = ucsRun:setPPLongDelay(ppList,varIndex[0],wEvo)

   # Zero the FID data
      sumData = 0*sumData

   # Accumulate scans
      for(scan = 0 to nrScans-1)
   
       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

       # Send all parameter values to DSP
          ucsRun:updatePPParameters(ppList,guipar,wvPort)  

       # Wait for repetition time and check for abort
         check = ucsRun:checkTiming(guipar,scan,pcList)
         if(check == "abort")
            return(0)
         endif
   
       # Run the pulse program and collect the data
          ucsUtilities:suspendLock() # turn lock control loop off
         (status,data) = ucsRun:getData(totPnts,guipar)
          ucsUtilities:resumeLock()  # turn lock control loop on
   
       # See if stop button/escape key pressed
         if(status != "ok")
            return(0)
         endif

       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
         (phasedTimeData,spectrum) = ucsRun:transformData(zerofill(sumData.*flt, totPnts*zf, "end"),fAxis,guipar,"fid")
         if(evoStep < 0)
            ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                     "FID - dummy cycle $-evoStep$, Scan $scan+1$","Spectrum",
                                     "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
         else
            ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                     "FID - evolution time $evolutionTime/1000,1.3f$ ms, Scan $scan+1$","Spectrum",
                                     "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
         endif

       # Check if complete button pressed
         if(check == "finish")
            scan = scan+1
            exitfor()
         endif
      
      next(scan)

     # Record the FID data and then FT it. Display results as images.
      if(evoStep >= 0)
         sumData2D[~,evoStep] = sumData
         imageData2D = fft_local:2d(sumData2D,zf*totPnts,nrSteps*zf,"sinebellsquared","sinebellsquared","FTFid","FTFid","yes")
         imageData2D = reflect(imageData2D,"horiz")
         pd1->draw("false")
         pd2->draw("false")
         pd1->image(sumData2D,[tAxis[0],tAxis[-1]]/1e6,[1,nrSteps]/bw2Hz)
         pd1->xlabel("t2 - Acquisition time (s)")
         pd1->ylabel("t1 - Mixing time (s)")
         pd1->title("Raw data ($(100*(evoStep+1)/nrSteps),1.1f$%)")
      # Plot the image data
         mn = 30*sd(imageData2D[[0:63],~])
         mx = max(imageData2D)
         if(mx <= mn); mx = mn*2; endif;
         pd2->image(imageData2D,axisX,axisY)
         pd2->contour(10,2)
         pd2->datamapping("log")
         pd2->autorange("false")
         pd2->imagerange(mn,mx)
         pd2->xlabel("f2 - 1H (ppm)")
         pd2->ylabel("f1 - 13C (ppm)")
         pd2->title("2D HSQC spectrum")
         pd2->grid->xgrid("on")
         pd2->grid->ygrid("on")
         pd2->grid->finexgrid("on")
         pd2->grid->fineygrid("on")
         pd2->axes->xrange(xRange)
         pd2->axes->yrange(yRange)
         pd1->draw("true")
         pd2->draw("true")
      endif

      if(check == "finish")
         exitfor()
      endif

   next(evoStep)

# Save the data
   ucsFiles:saveImage(pd1,:getPlotInfo("im1"),guipar,"noReport")
   ucsFiles:saveImage(pd2,:getPlotInfo("im2"),guipar,"simpleReport")
   ucsFiles:saveMNovaData(pd1,:getPlotInfo("im1"),guipar,"simpleReport")

# Save the processing parameters
   :saveProcPar(guipar,xRange,yRange)

# Pack the data for return
   result = struct()
   result->mTime     = sumData2D/scan
   result->mTimeAxes = [tAxis[0]/1e6,tAxis[-1]/1e6,1/bw2Hz,nrSteps/bw2Hz]
   result->mFreq     = imageData2D/scan
   result->mFreqAxes = [fAxis[0],fAxis[-1],-bw2Hz,bw2Hz]
   result->par       = struct(guipar)

# Return the results
   return(result)

endproc("execpp")

########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = (nrSteps+dummyCycles)*nrScans + useStartDelay
   duration = totScans*repTime/1000

endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["im1","HSQC_FID.pt2","im2","HSQC_Spectrum.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


#################################
# Save the processing parameters
#################################

procedure(saveProcPar, guipar, xrange, yrange)

   assignlist(guipar)

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq1H)
      yrange = yrange*single(b1Freq13C)
   endif
  
   procpar = ["f1DisplayInPPM = \"$usePPMScale$\"",
              "f2DisplayInPPM = \"$usePPMScale$\"",
              "f1FTOrigin     = \"Start\"",
              "f2FTOrigin     = \"Start\"",
              "f1FTType       = \"Complex\"",
              "f2FTType       = \"Complex\"",
              "f1Filter       = \"exponential\"",
              "f2Filter       = \"exponential\"",
              "f1FTInvert     = \"yes\"",
              "f2FTInvert     = \"no\"",
              "f1PhaseMethod  = \"Magnitude\"",
              "f2PhaseMethod  = \"None\"",
              "f1PPMOffset    = $centerFreq13CPPM$",
              "f2PPMOffset    = $centerFreq1HPPM$",
              "f1ZeroFill     = $zf$",
              "f2ZeroFill     = $zf$",
              "plotWidth      = $xrange[1]-xrange[0]$",
              "plotStart      = $xrange[0]$",
              "plotWidth2     = $yrange[1]-yrange[0]$",
              "plotStart2     = $yrange[0]$"]

   cd("$dataDirectory$\\$expName$")
   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif

   save("proc.par",procpar)

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()
