#########################################################
# 
# HSQCtgME
#
# A pulse sequence suitable for performing an HSQCtgME experiment
#
# H  45-d1-180-d1-135-90-d2-180-d2-90----evo-180-evo-d1-180-d1----90-d2-180-d2-acq-
# C  ---d1-180-d1--------d2-180-d2----90-evo-----evo-d1-180-d1-90----d2-180-d2-dec-
# G  ----------------G---------------G---------------------------G----------------G
#
# Copyright (c) Magritek Ltd 2024
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(HSQCtgME, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"HSQCtgME")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("HSQCtgME")
   else
      gExpt->addExperiment(ppGroup,"HSQCtgME",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["wEvo"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["b1Freq        = b1Freq1H",
          "offFreq1H     = (centerFreq1HPPM-wvPPMOffset1H)*b1Freq1H",
          "offFreq13C    = (centerFreq13CPPM-wvPPMOffset13C)*b1Freq13C",
          "O1            = offFreq1H",
          "f1H           = double(b1Freq1H)+double(offFreq1H/1e6d)",
          "f13C          = double(b1Freq13C)+double(offFreq13C/1e6d)",
          "nPnts         = nrPnts",
          "nxShim        = xshim",
          "nyShim        = yshim",
          "nzShim        = zshim",
          "nxSpoil       = xshim-(spoilAmp*xshim/(abs(xshim)+0.1))",
          "nySpoil       = yshim-(spoilAmp*yshim/(abs(yshim)+0.1))",
          "nzSpoil       = zshim-(spoilAmp*zshim/(abs(zshim)+0.1))",
          "nxSpoilFinal   = xshim-(spoilAmpFinal*xshim/(abs(xshim)+0.1))",
          "nySpoilFinal   = yshim-(spoilAmpFinal*yshim/(abs(yshim)+0.1))",
          "nzSpoilFinal   = zshim-(spoilAmpFinal*zshim/(abs(zshim)+0.1))",
          "a0            = 0",
          "a90HC         = 90AmplitudeHC",
          "a180HC        = 180AmplitudeHC",
          "a90C          = 90Amplitude13C",
          "a180C         = 180Amplitude13C",
          "aDec          = aCDec",
          "dPulse        = pulseLength13C",
          "d90C          = pulseLength13C*0.5",
          "d45C          = pulseLength13C*0.5",
          "d135C         = pulseLength13C*1.5",
          "d90Cdec       = 1*pulseLengthC180Dec/2",
          "d180Cdec      = 1*pulseLengthC180Dec",
          "d270Cdec      = 3*pulseLengthC180Dec/2",
          "d360Cdec      = 2*pulseLengthC180Dec",
          "dSpoil        = 1*spoilDur",
          "dSpoil3       = 3*spoilDur",
          "dSpoil4       = 4*spoilDur",
          "dSpoil5       = 5*spoilDur",
          "dSpoilFinal   = spoilDurFinal",
          "dStab         = gradStab",
          "dAcq          = 0.85*dwellTime-38",
          "BalanceME     = 2/3*dPulse-7",
          "dCoup1        = 1e6/(2*jch)-2*pulseLength13C  -3*pgo",
          "dCoup2        = 1e6/(4*jch)-2*pulseLength13C  -2*pgo",
          "dCoup1a       = 1e6/(2*jch)-3*pulseLength13C/2-2*pgo-dSpoil-dStab",
          "dCoup1b       = 1e6/(2*jch)-2*pulseLength13C  -2*pgo-dSpoil-dStab",
          "dCoup3        = 1e6/(4*jch)-3*pulseLength13C/2-1*pgo-dAcq",
          "dRef          = 3*dPulse+4*pgo",
          "bandwidth2    = single(bandwidthf1PPM*b1Freq13C/1000)",
          "wEvo          = 1e3/(2*bandwidth2)",
          "totPnts       = nrPnts",
          "totTime       = acqTime",
          "waltzDuration = WALTZ16:duration(pulseLengthC180Dec/2,pgo)",
          "nLoops        = trunc(1000*acqTime/waltzDuration)+1"]
   var = ["wEvo"]
   pp_list = ["nPnts","f1H","f13C","a90HC","p1","d45C","dCoup1","p2","a90C","p5","dPulse","a180HC","p3","a180C","p7","d135C","nxSpoil","nySpoil","nzSpoil","dSpoil3","nxShim","nyShim","nzShim","dStab","dCoup2","dSpoil5","a0","p8","d90C","wEvo","p4","dRef","dSpoil","dCoup1a","dCoup1b","p9","dSpoil4","p6","p10","dCoup3","nLoops","l1","aDec","p12","d270Cdec","p11","d360Cdec","d180Cdec","d90Cdec","nxSpoilFinal","nySpoilFinal","nzSpoilFinal","dSpoilFinal"]
   pp_name = "HSQCtgME.p"
   phase_list = [0,0,0,0;0,0,0,0;1,1,1,1;0,0,0,0;1,1,1,1;0,0,0,0;0,0,0,0;0,2,0,2;0,0,2,2;0,0,0,0;0,0,0,0;2,2,2,2;2,0,0,2]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 26/2/2021 CDE
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Optimise 13C performance on Multi-X spectrometer
   SpinsolveParameterUpdater:setXChannel("13C")

# Make all gui parameters available
   assignlist(guipar)

# Variables to allow FT
   windowvar(wv_mIn,wv_rowFt,wv_mOut)

# Storage for output data
   sumData     = cmatrix(totPnts)
   sumData2D   = cmatrix(totPnts, nrSteps*2)
   imageData2D = cmatrix(totPnts*zf, nrSteps*zf)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # ms
   fAxis = [-totPnts*zf/2:totPnts*zf/2-1]/(totTime*zf)*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Make subplots. wvPP is the current-plot's parent
   (prt,prf,pd1,pd2) = ucsPlot:getPlotReferences()

# Work out frequency axes scales, labels and ranges
   (fAxisDisp,fAxisLabel,axisLabely,
    axisLabelx,axisY,axisX,yRange,xRange) = ucsPlot:generate2DFrequencyAxes(prf, pd2, fAxis, b1Freq13C, b1Freq1H, 
                                                                            wvPPMOffset13C, wvPPMOffset1H, 
                                                                            offFreq13C, offFreq1H, 
                                                                            dispRangeMinPPMf1,dispRangeMaxPPMf1,
                                                                            dispRangeMinPPM,dispRangeMaxPPM,
                                                                            guipar)

   bw2Hz = bandwidth2*1000

# Loop over the evolution time
   for(evoStep = -dummyCycles to nrSteps-1)   # evoStep <= 0 are dummy scans


 # FAD phase cycle to move zero frequency spike to edge
       pcListFAD = pcList
       if (evoStep >= 0)
          pcListFAD[~,7] = (pcList[~,7] + (evoStep % 2)*32768)
          pcListFAD[~,12] = (pcList[~,12] + (evoStep % 2)*32768)
      endif

    # Hypercomplex data loop
      for(ph = 0 to 1)   

         # Set the phase of the 13C 90
         pcListStates = pcListFAD
         pcListStates[~,7] = (pcListFAD[~,7] + (ph*16384))

         # Set the mixing time
         if (evoStep >= 0)
            evolutionTime = 1e6/bw2Hz*evoStep
            wEvo = 1 + (evolutionTime)/2
         else
            evolutionTime = 1e6/bw2Hz
            wEvo = 1
         endif
         
         ppList = ucsRun:setPPLongDelay(ppList,varIndex[0],wEvo)

       # Zero the FID data
         sumData = 0*sumData

       # Accumulate scans
         for(scan = 0 to nrScans-1)

           # Set phases for this scan
            (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcListStates,pcIndex)

          # Send all parameter values to DSP
             ucsRun:updatePPParameters(ppList,guipar,wvPort)  
       
          # Wait for repetition time and check for abort
            check = ucsRun:checkTiming(guipar,scan,pcList)
            if(check == "abort")
               return(0)
            endif

           # Run the pulse program and collect the data
             ucsUtilities:suspendLock() # turn lock control loop off
            (status,data) = ucsRun:getData(totPnts,guipar)
             ucsUtilities:resumeLock()  # turn lock control loop on
 
           # See if stop button/escape key pressed
            if(status != "ok")
               return(0)
            endif

           # Accumlate the data
            sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)
            (phasedTimeData,spectrum) = ucsRun:transformData(zerofill(sumData.*flt, totPnts*zf, "end"),fAxis,guipar,"fid")
            if(evoStep < 0)
               ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                         "FID - dummy cycle $-evoStep$, Scan $scan+1$","Spectrum",
                                         "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
            else
               ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                         "FID - evolution time $evolutionTime/1000,1.3f$ ms, Scan $scan+1$","Spectrum",
                                         "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
            endif

          # Check if complete button pressed
            if(check == "finish")
               scan = scan+1
               exitfor()
            endif

         next(scan)

         # Record the FID data and then FT it. Display results as images.
         if(evoStep >= 0)
            sumData2D[~,evoStep*2+ph] = sumData
            pd1->draw("false")
            pd1->image(sumData2D,[tAxis[0],tAxis[-1]]/1e6,[1,nrSteps]/(bw2Hz))
            pd1->xlabel("t2 - Acquisition time (s)")
            pd1->ylabel("t1 - Evolution time (s)")
            pd1->title("Raw data ($(100*(evoStep+1)/nrSteps),1.1f$%)")
            pd1->draw("true")
            # Transform the FID
            wv_mIn = sumData2D
            (f2Sz,f1Sz) = size(wv_mIn)
            # f2 transform
            apodizeNTransform2D:transformf2(zf*f2Sz,zf*f1Sz,
                         "sinebellsquared","Start","Hypercomplex","no","None")
         
            # f1 transform
            apodizeNTransform2D:transformf1(zf*f2Sz,zf*f1Sz,
                         "sinebellsquared", "Center","Complex","Hypercomplex","no","None")
            imageData2D = wv_mOut

            # Display the spectrum
            pd2->draw("false")
            mn = 30*sd(real(imageData2D[[0:63],~]))
            mx = max(real(imageData2D))
            if(mx <= mn); mx = mn*2; endif;
            pd2->image(imageData2D,axisX,axisY)
            pd2->contour(10,2)
            pd2->datamapping("log")
            pd2->autorange("false")
            pd2->imagerange(mn,mx)
            pd2->xlabel("f2 - 1H (ppm)")
            pd2->ylabel("f1 - 13C (ppm)")
            pd2->title("2D HSQC spectrum")
            pd2->grid->xgrid("on")
            pd2->grid->ygrid("on")
            pd2->grid->finexgrid("on")
            pd2->grid->fineygrid("on")
            pd2->axes->xrange(xRange)
            pd2->draw("true")
         endif

      next(ph)

     # Check for finish  
      if(check == "finish")
         exitfor()
      endif

   next(evoStep)

# Save the data
   ucsFiles:saveImage(pd1,:getPlotInfo("im1"),guipar,"noReport")
   ucsFiles:saveMNovaData(pd1,:getPlotInfo("im1"),guipar,"simpleReport")
   ucsFiles:saveImage(pd2,:getPlotInfo("im2"),guipar,"simpleReport")

# Save the processing parameters
   :saveProcPar(guipar,xRange,yRange)

# Pack the data for return
   result = struct()
   result->mTime     = sumData2D/scan
   result->mTimeAxes = [tAxis[0]/1e6,tAxis[-1]/1e6,1/bw2Hz,nrSteps/bw2Hz]
   result->mFreq     = imageData2D/scan
   result->mFreqAxes = [fAxis[0],fAxis[-1],-bw2Hz,bw2Hz]
   result->par       = struct(guipar)

# Return the results
   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = 2*(nrSteps+dummyCycles)*nrScans + useStartDelay
   duration = totScans*repTime/1000

endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["im1","HSQCtgME_FID.pt2","im2","HSQCtgME_Spectrum.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

#################################
# Save the processing parameters
#################################

procedure(saveProcPar, guipar, xrange, yrange)

   assignlist(guipar)
  
   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq1H)
      yrange = yrange*single(b1Freq13C)
   endif

   procpar = ["f1DisplayInPPM = \"$usePPMScale$\"",
              "f2DisplayInPPM = \"$usePPMScale$\"",
              "f1FTOrigin     = \"Center\"",
              "f2FTOrigin     = \"Start\"",
              "f1FTType       = \"Complex\"",
              "f2FTType       = \"Hypercomplex\"",
              "f1Filter       = \"sinebellsquared\"",
              "f2Filter       = \"sinebellsquared\"",
              "f1FTInvert     = \"no\"",
              "f2FTInvert     = \"no\"",
              "f1PhaseMethod  = \"Magnitude\"",
              "f2PhaseMethod  = \"None\"",
              "f1PPMOffset    = $centerFreq13CPPM$",
              "f2PPMOffset    = $centerFreq1HPPM$",
              "f1ZeroFill     = $zf$",
              "f2ZeroFill     = $zf$",
              "plotWidth      = $xrange[1]-xrange[0]$",
              "plotStart      = $xrange[0]$",
              "plotWidth2     = $yrange[1]-yrange[0]$",
              "plotStart2     = $yrange[0]$"]

   cd("$dataDirectory$\\$expName$")
   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif

   save("proc.par",procpar)

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()
