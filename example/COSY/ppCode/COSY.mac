#########################################################
# 
# COSY
#
# A pulse sequence suitable for performing a
# gradient selected 2D COSY NMR experiment.
#
# H 90-evo-90-acq-delay--
# G ------G--G---G-----G-
#
# Copyright (c) Magritek Ltd 2024
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(COSY, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"COSY")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("COSY")
   else
      gExpt->addExperiment(ppGroup,"COSY",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds ["wEvol"] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

# Provide a pilot Proton scan for MNova
   if(RunPilot("COSY","Proton",guipar) == 0)
      return(0)
   endif

# Run the COSY  
   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["n1          = nrPnts",
          "nxShim      = xshim",
          "nyShim      = yshim",
          "nzShim      = zshim",
          "ny          = (yshim-1.0*spoilAmp)",
          "nx          = (xshim-1.0*spoilAmp)",
          "nz          = (zshim-1.0*spoilAmp)",
          "dX          = COSY_pp:GetPulseLength(cosyType, pulseLength1H)",
          "a90         = 90Amplitude1H",
          "d90         = pulseLength1H",
          "bandwidth2  = single(bandwidthf1PPM*b1Freq1H/1000)",
          "wEvol       = 1e3*nrSteps/bandwidth2-d90-pgo",
          "dSpoil      = spoilDelay",
          "dStab       = gradStab",
          "offFreq1H   = (centerFreqPPM-wvPPMOffset1H)*b1Freq1H",
          "freqCh1 = b1Freq1H + offFreq1H/1e6d",
          "totPnts     = nrPnts",
          "totTime     = acqTime"]
   var = ["wEvol"]
   pp_list = ["a90","p1","d90","wEvol","nx","ny","nz","dSpoil","nxShim","nyShim","nzShim","dStab","p2","dX","n1"]
   pp_name = "COSY.p"
   phase_list = [0,2,0,2;0,0,2,2;0,2,0,2]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


#######################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 2017-2021 CDE
#
#######################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Storage for output data
   sumData2D   = cmatrix(totPnts, nrSteps)
   imageData2D = cmatrix(totPnts*zf, nrSteps*zf)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000            # ms
   fAxis = ([0:1:zf*totPnts-1]-zf*totPnts/2)/totTime/zf*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Make subplots. wvPP is the current-plot's parent
   (prt,prf,pd1,pd2) = ucsPlot:getPlotReferences()
   prt->showimag("true")
   prf->showimag("false")

# First order phase correction
   guipar = guipar + ["firstOrderCorr = 2*pi"]

# Work out frequency axes scales, labels and ranges
   (fAxisDisp,fAxisLabel,axisLabely,
    axisLabelx,axisY,axisX,yRange,xRange) = ucsPlot:generate2DFrequencyAxes(prf, pd2, fAxis, b1Freq1H, b1Freq1H, 
                                                                            wvPPMOffset1H, wvPPMOffset1H, 
                                                                            offFreq1H, offFreq1H, 
                                                                            dispRangeMinPPM,dispRangeMaxPPM,
                                                                            dispRangeMinPPM,dispRangeMaxPPM,
                                                                            guipar)

# f1 bandwidth
   bw2Hz = bandwidth2*1000

# Loop over the evolution time
   for(evolutionStep = -dummyCycles to nrSteps-1)   # evolutionStep < 0 is dummy scan

   # FAD phase cycle to move zero frequency spike to edge
       pcListFAD = pcList
       if (evolutionStep >= 0)
          pcListFAD[~,0] = (pcList[~,0] + (evolutionStep % 2)*32768)
          pcListFAD[~,2] = (pcList[~,2] + (evolutionStep % 2)*32768)
      endif

    # Set the evolution time
      if(evolutionStep >= 0)
         evolutionTime = 1e6/bw2Hz*(evolutionStep+1)
      else
         evolutionTime = 1e6/bw2Hz
      endif
      wEvol = evolutionTime-d90-pgo
      ppList = ucsRun:setPPLongDelay(ppList,varIndex[0],wEvol)
 
   # Initialise row data
      sumData = cmatrix(totPnts)

   # Accumulate scan
      for(scan = 0 to nrScans-1)

       # Set phases for this scan
         (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcListFAD,pcIndex)

       # Send all parameter values to DSP
         ucsRun:updatePPParameters(ppList,guipar)  

       # Wait for the repetition time to complete
         check = ucsRun:checkTiming(guipar,scan,pcList)
         if(check == "abort")
            return(0)
         endif

       # Run the pulse program and collect the data
          ucsUtilities:suspendLock() # turn lock control loop off
         (status,data) = ucsRun:getData(totPnts,guipar)
          ucsUtilities:resumeLock()  # turn lock control loop on

       # See if stop button/escape key pressed
         if(status != "ok")
            return(0)
         endif
   
       # Accumlate the data
         sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

       # Transform the 1D data
         (phasedTimeData,spectrum) = ucsRun:transformData(zerofill(sumData.*flt, totPnts*zf, "end"),fAxis,guipar,"fid")

       # Plot the 1D data 
         if(evolutionStep < 0)
            ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                     "FID - dummy cycle $-evolutionStep$, Scan $scan+1$","Spectrum",
                                     "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
         else
            ucsPlot:graphTimeAndFreq(prt,prf,tAxis,sumData,fAxisDisp,spectrum,scan,guipar,
                                     "FID - evolution time = $evolutionTime/1000,1.3f$ ms, Scan $scan+1$","Spectrum",
                                     "Time (ms)","Amplitude",fAxisLabel,"Amplitude")
         endif

         if(check == "finish")
            scan = scan+1
            exitfor()
         endif
    
      next(scan) # End of accumulation loop

    # Record the FID data and then FT it. Display results as images.
      if(evolutionStep >= 0)
      # Record the data
         sumData2D[~,evolutionStep] = sumData
      # FT the data
         imageData2D = fft_local:2d(sumData2D,zf*totPnts,nrSteps*zf,"sinebellsquared","sinebellsquared","FTFid","FTFid","yes")
         imageData2D = reflect(imageData2D,"horiz")
      # Plot the time domain data
         pd1->draw("false")
         pd2->draw("false")
         pd1->image(sumData2D,[tAxis[0],tAxis[-1]]/1e6,[1,nrSteps]/bw2Hz)
         pd1->xlabel("t2 - Acquisition time (s)")
         pd1->ylabel("t1 - Evolution time (s)")
         pd1->title("Raw data ($(100*(evolutionStep+1)/nrSteps),1.1f$%)")
      # Plot the COSY data
         mn = 30*sd(imageData2D[[0:63],~])
         mx = max(imageData2D)
         if(mx <= mn); mx = mn*2; endif;
         pd2->image(imageData2D,axisX,axisY)
         pd2->contour(10,2)
         pd2->datamapping("log")
         pd2->autorange("false")
         pd2->imagerange(mn,mx)
         pd2->title("2D COSY spectrum")
         pd2->xlabel("f2 - 1H (ppm)")
         pd2->ylabel("f1 - 1H (ppm)")
         pd2->grid->xgrid("true")
         pd2->grid->ygrid("true")
         pd2->grid->finexgrid("true")
         pd2->grid->fineygrid("true")
         pd2->axes->xrange(xRange)
         pd2->axes->yrange(yRange)
         pd1->draw("true")
         pd2->draw("true")
      endif

    # Exit from experiment if finished
      if(check == "finish")
         exitfor()
      endif

   next(evolutionStep) # End of evolution time loop

# Save the data
   ucsFiles:saveImage(pd1,:getPlotInfo("im1"),guipar,"noReport")
   ucsFiles:saveImage(pd2,:getPlotInfo("im2"),guipar,"simpleReport")
   ucsFiles:saveMNovaData(pd1,"data.2d",guipar,"simpleReport")

# Save the processing parameters
   :saveProcPar(guipar,xRange,yRange)

# Pack the data for return
   result = struct()
   result->mTime     = sumData2D/scan
   result->mTimeAxes = [tAxis[0]/1e6,tAxis[-1]/1e6,1/bw2Hz,nrSteps/bw2Hz]
   result->mFreq     = imageData2D/scan
   result->mFreqAxes = [fAxis[0],fAxis[-1],-bw2Hz,bw2Hz]
   result->par       = struct(guipar)

# Return the results
   return(result)

endproc("execpp") # Don't remove argument

########################################################
# Return expected experiment duration in seconds
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = (nrSteps+dummyCycles)*nrScans + useStartDelay  
   duration = totScans*repTime/1000

# Add pilot scan time
   if(useStartDelay)
      duration = duration + 10
   else
      duration = duration + 7
   endif
   if(useEndDelay)
      duration = duration + 10
   endif

endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["im1","cosyFID.pt2","im2","cosySpectrum.pt2"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)

#################################
# Save the processing parameters
#################################

procedure(saveProcPar,guipar,xrange,yrange)

   assignlist(guipar)

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq1H)
      yrange = yrange*single(b1Freq1H)
   endif

   procpar = ["f1DisplayInPPM   = \"$usePPMScale$\"",
              "f2DisplayInPPM   = \"$usePPMScale$\"",
              "f1FTOrigin       = \"Start\"",
              "f2FTOrigin       = \"Start\"",
              "f1FTType         = \"Complex\"",
              "f2FTType         = \"Complex\"",
              "f1WindowFunction = \"sinebellsquared\"",
              "f1WindowFunction = \"sinebellsquared\"",
              "f1FTInvert       = \"yes\"",
              "f2FTInvert       = \"no\"",
              "f1PhaseMethod    = \"Magnitude\"",
              "f2PhaseMethod    = \"None\"",
              "f1PPMOffset      = $centerFreqPPM$",
              "f2PPMOffset      = $centerFreqPPM$",
              "f1ZeroFill       = $zf$",
              "f2ZeroFill       = $zf$",
              "plotWidth        = $xrange[1]-xrange[0]$",
              "plotStart        = $xrange[0]$",
              "plotWidth2       = $yrange[1]-yrange[0]$",
              "plotStart2       = $yrange[0]$"]

   if(isvar("exptNr"))
      cd("$dataDirectory$\\$expName$\\$exptNr$")
   else
      cd("$dataDirectory$\\$expName$")
   endif

   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif
   save("proc.par",sortlist(procpar),"truedoubles")

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()
